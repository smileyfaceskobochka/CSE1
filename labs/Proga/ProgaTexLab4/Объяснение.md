# Двусвязный список и алгоритм обработки последовательности

## Двусвязный список: основы

### Что такое двусвязный список?
Двусвязный список — это структура данных, состоящая из узлов (элементов), в которых хранятся:
- Значение элемента (данные);
- Указатель на следующий элемент (next);
- Указатель на предыдущий элемент (prev).

Каждый узел связан с соседними узлами, что позволяет перемещаться по списку в обоих направлениях: вперёд (next) и назад (prev).

### Преимущества двусвязного списка:
- Быстрое удаление/добавление элементов в середине или в конце списка;
- Возможность перемещения в обе стороны.

### Недостатки:
- Более сложная структура, чем у односвязного списка;
- Требует больше памяти (дополнительный указатель на prev).

### Когда использовать двусвязный список?
Двусвязный список полезен, если:
- Требуется часто добавлять или удалять элементы в середине/конце списка;
- Нужна возможность двигаться как вперёд, так и назад.

Однако в простых задачах, таких как обработка строки с фиксированной длиной, использование двусвязного списка может быть избыточным. Альтернативные структуры, такие как массив или стек, могут быть проще и быстрее.

### Структура данных

```c
typedef struct Node {
    char val;               // Хранит значение символа
    struct Node* prev;      // Указатель на предыдущий узел
    struct Node* next;      // Указатель на следующий узел
} Node;

typedef struct LList {
    Node* head;             // Указатель на первый узел списка
    Node* tail;             // Указатель на последний узел списка
} LList;
```

## Основные операции с двусвязным списком

### Создание узла
```c
Node* createNode(char val) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->val = val;
    newNode->prev = NULL;
    newNode->next = NULL;
    return newNode;
}
```
Создаётся новый узел с заданным значением и пустыми указателями на соседние элементы.

### Добавление элемента в конец
```c
void append(LList* list, char val) {
    Node* newNode = createNode(val);
    if (!list->head) {
        list->head = newNode;
        list->tail = newNode;
    } else {
        newNode->prev = list->tail;
        list->tail->next = newNode;
        list->tail = newNode;
    }
}
```
1. Если список пустой, новый узел становится и головой, и хвостом.
2. Если список непустой, новый узел добавляется после текущего хвоста, и указатель tail обновляется.

### Удаление последнего элемента
```c
void remLast(LList* list) {
    if (list->tail) {
        Node* temp = list->tail;
        if (list->tail->prev) {
            list->tail = list->tail->prev;
            list->tail->next = NULL;
        } else {
            list->head = NULL;
            list->tail = NULL;
        }
        free(temp);
    }
}
```
Удаляется последний узел:
- Если список содержит несколько элементов, tail обновляется на предыдущий узел;
- Если в списке один элемент, список становится пустым.

### Преобразование списка в строку
```c
char* toString(LList* list) {
    int length = 0;
    Node* current = list->head;
    while (current) {
        length++;
        current = current->next;
    }

    char* res = (char*)malloc(length + 1);
    current = list->head;
    for (int i = 0; i < length; i++) {
        res[i] = current->val;
        current = current->next;
    }
    res[length] = '\0';
    return res;
}
```
1. Сначала вычисляется длина списка;
2. Затем создаётся строка и заполняется значениями узлов;
3. Завершается символом конца строки (\0).

## Алгоритм обработки последовательности

### Задача

Последовательность символов заканчивается точкой (`.`). В ней может встречаться специальная последовательность `Ch`, которая удаляет предыдущий символ. Требуется обработать последовательность, удаляя символы перед каждым `Ch`, и вернуть результат.

### Реализация алгоритма
```c
char* processSeq(const char* seq) {
    LList* list = createList();
    int i = 0;

    while (seq[i] != '\0') {
        if (seq[i] == 'C' && seq[i + 1] == 'h') {
            remLast(list);
            i += 2; // Пропускаем "Ch"
        } else if (seq[i] == '.') {
            i++; // Пропускаем точку, завершаем ввод строки
            break;
        } else {
            append(list, seq[i]);
            i++;
        }
    }

    char* res = toString(list);

    // Освобождаем память
    while (list->head) {
        remLast(list);
    }
    free(list);

    return res;
}
```
1. Создаётся пустой двусвязный список для хранения символов.
2. Входная строка анализируется посимвольно:
   - Если встречается `Ch`, вызывается `remLast`, чтобы удалить последний добавленный символ.
   - Если встречается точка (`.`), обработка прекращается.
   - В остальных случаях символ добавляется в список.
3. После обработки список преобразуется в строку с помощью `toString`.
4. Освобождается память, выделенная под список.

### Пример работы алгоритма
#### Вход: `abCdefChg.`
1. Добавляем `a`, `b`, `C`, `d`, `e`, `f`;
2. При встрече `Ch` удаляем `f`;
3. Добавляем `g`;
4. Точка завершает ввод.

#### Выход: `abCdeg`.

## Итог

Использование двусвязного списка в данной задаче эффективно для работы с динамическими данными и удалением элементов. Однако если длина строки фиксирована и операции просты, то:
- **Массив** или **стек** могут быть более подходящими, так как они проще в реализации и занимают меньше памяти.

Если условия задачи допускают, рассмотрите упрощение структуры данных для улучшения производительности и упрощения кода.

